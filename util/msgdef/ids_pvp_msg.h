#ifndef _IDS_PVP_MSG_H_INCLUDED_ 
#define _IDS_PVP_MSG_H_INCLUDED_ 
//gerenate from ids_pvp_msg.defsrc.hpp! DO NOT edit this file !! 



//#include <arpa/inet.h>
//#include <cassert>

#pragma pack(1)
const static uint32_t U32_PVP_PROTOCAL_VERSION = 20140130;

enum enumIdsPvpMsg
{
	E_IDS_PVP_MSG_NULL = 0,   //min
	E_IDS_PVP_MSG_HEART_BEAT,
	E_IDS_PVP_MSG_ERROR,

	E_IDS_PVP_MSG_MATCH,
	E_IDS_PVP_MSG_MATCH_OK,
	
	E_IDS_PVP_MSG_START,
	
	E_IDS_PVP_MSG_GAME_SVR_UDP_ADDR,	
	E_IDS_PVP_MSG_CLIENT_UDP_ADDR,
	E_IDS_PVP_MSG_CLIENT_UDP_ADDR_ACKNOWLEDGE,
	
	E_IDS_PVP_MSG_SPAWN_FRUIT,
	E_IDS_PVP_MSG_SLICE_FRUIT,
	E_IDS_PVP_MSG_OTHERS_SLICE_FRUIT,

	E_IDS_PVP_MSG_SPAWN_ITEM,
	E_IDS_PVP_MSG_SLICE_ITEM,
	E_IDS_PVP_MSG_OTHERS_SLICE_ITEM,

	E_IDS_PVP_MSG_USE_ITEM,
	E_IDS_PVP_MSG_OTHERS_USE_ITEM,

	E_IDS_PVP_MSG_SPAWN_BOMB,
	E_IDS_PVP_MSG_SLICE_BOMB,
	E_IDS_PVP_MSG_OTHERS_SLICE_BOMB,
	

	E_IDS_PVP_MSG_TIME_OVER,
	E_IDS_PVP_MSG_FINISH,
	E_IDS_PVP_MSG_GAME_OVER,
	
	E_IDS_PVP_MSG_MAX,   //max 
};

namespace PvpConst
{
	enum
	{
		PLATEFORM_NULL = 0,
		PLATEFORM_ANDROID = 1,
		PLATEFORM_IOS = 2,
		COUNT_OF_ONE_PAIR = 3,
		NICK_NAME_LEN = 32,
		PIC_URL_LEN = 128,
		SCREEN_WIDTH = 960,
		SCREEN_HIGH = 640,
		SPAWN_START_POS_X = 200,
		SPAWN_START_POS_Y = 150,

        MAX_CHUCK_WAIT = 200,
		MAX_SPAWN_POS_OFFSET = 200,
		MAX_ROBOT_SLICE_FRUIT_COUNT = 6,
	};

	
	enum enumPvpSpawnBornDirection
	{
		TOP_TO_BOTTOM = 0,
		BOTTOM_TO_TOP,
		LEFT_TO_RIGHT,
		RIGHT_TO_LEFT,
		BORN_DIRECTION_MAX,//max 
	};

	enum
	{
		PVP_ROBOT_UID = (uint64_t(-1)),
	};
	enum
		{
			MATCHAFFAIR_ID_90_SECONDS = 0,
			MATCHAFFAIR_ID_180_SECONDS = 1,
			MATCHAFFAIR_ID_MAX = 2,
		};

	enum 
		{
			ITEM_GHOST_FACE = 0,
			ITEM_BIND_BOMBS,
			ITEM_REDUCE_SCORE,
			ITEM_INCREASE_SPEED,
			ITEM_ROTATING_KNIFE,
			ITEM_NO_HURT_GUARD,
			ITEM_BOUNCE_ATTACK,
			ITEM_ID_MAX, //边界值
			//if add item to find out and fix ARR_CONST_GOOD_ITEMS and ARR_CONST_BAD_ITEMS
		};

	   static const unsigned ARR_CONST_GOOD_ITEMS[] =
       {
			PvpConst::ITEM_NO_HURT_GUARD,
			PvpConst::ITEM_BOUNCE_ATTACK,
       };

		static const unsigned ARR_CONST_BAD_ITEMS[] =
        {
            PvpConst::ITEM_GHOST_FACE,
			PvpConst::ITEM_BIND_BOMBS,
			PvpConst::ITEM_REDUCE_SCORE,
			PvpConst::ITEM_INCREASE_SPEED,
			PvpConst::ITEM_ROTATING_KNIFE,
        };
           
	enum
		{
			MAX_GOOD_ITEMS_COUNT_90_SECONDS = 4,
			MAX_BAD_ITEMS_COUNT_90_SECONDS = 2,
			MAX_GOOD_ITEMS_COUNT_180_SECONDS = 8,
			MAX_BAD_ITEMS_COUNT_180_SECONDS = 3,
		};

		enum
		{
			MAX_ITEMS_SPAWN_ONCE = 3,
			MAX_BOMBS_SPAWN_ONCE = 2,
			MAX_FRUITS_SPAWN_ONCE = 30,			
		};


		enum enumFruitTypeID
			{
				WATERMELON = 0,//      "watermelon"        // 西瓜
				STRAWBERRY,//      "strawberry"        // 草霉
				PEAR,//            "pear"              // 梨
				KIWI,//            "kiwi"              // 猕猴桃
				BANANA,//          "banana"            // 香蕉
				MANGO,//           "mango"             // 芒果
				PLUM,//            "plum"              // 李子
				LEMON,//           "lemon"             // 柠檬
				PASSIONFRUIT,//    "passionFruit"      // 番石榴
				LIME,//            "lime"              // 酸橙
				PEACH,//           "peach"             // 桃
				CHERRY,//          "cherry"            // 樱桃
				ORANGE,//          "orange"            // 桔子
				COCONUT,//         "coconut"           // 椰子
				DRAGONFRUIT,//     "dragonFruit"       // 火龙果
				PINEAPPLE,//       "pineapple"         // 凤梨 / 菠萝
				REDAPPLE,//        "redApple"          // 红苹果
				GREENAPPLE,//      "greenApple"        // 绿苹果
				FOOTBALL,//        "football"          // 足球
				BANANA_FRENZY,//   "bananaFrenzy"      // 疯狂香蕉
				BANANA_FREEZE,//   "bananaFreeze"      // 冰冻香蕉
				BANANA_MULTIPLY,// "bananaMultiply"    // 双倍香蕉
				PEACH_POWER,//     "peachPower"        // 体力桃子
				POMEGRANATE,//     "pomegranate"       // 石榴
				STARFRUIT,//       "starfruit"         // 杨桃
				GEM_BOX,//         "gembox"            // 宝箱
				RED_PACKET,//      "redbag"            // 红包
				FRUIT_TYPE_ID_MAX,
			};

		static const unsigned ARR_CONST_SPECAIL_FRUIT_TYPE_ID[] =
        {
            PvpConst::BANANA_FRENZY,
			PvpConst::BANANA_FREEZE,
			PvpConst::BANANA_MULTIPLY,
        };

		enum enumBombTypeID
			{
				BLUE_BOMB,
			};
};


struct PvpProtocalVersion
{
    PvpProtocalVersion()
    {
        m_u32Version = htonl(U32_PVP_PROTOCAL_VERSION);
    }
	uint32_t GetVersion() const
	{
		return ntohl(m_u32Version);
	}

private:
    uint32_t m_u32Version;
};

struct PvpBussinessMsgHead
{
private:
//#ifdef _DEBUG	
//	char m_szDebugString[52];
//#endif
	int32_t m_eMsg;
public:

	void SetMsg(enumIdsPvpMsg eMsg)
	{
		m_eMsg = (enumIdsPvpMsg)htonl(eMsg);
//#ifdef _DEBUG	
//	snprintf(m_szDebugString, sizeof(m_szDebugString), "Msg=%u", eMsg);
//#endif
	}
	enumIdsPvpMsg GetMsg() const
	{
		return(enumIdsPvpMsg) ntohl(m_eMsg);
	}
};





































































































static Vector3fx htonVector3fx(const Vector3fx & v3)
{
    Vector3fx tmp;
    tmp.x = htonl(v3.x);
    tmp.y = htonl(v3.y);
    tmp.z = htonl(v3.z);
    
    return tmp;
}

static Vector3fx ntohVector3fx(const Vector3fx & v3)
{
    Vector3fx tmp;
    tmp.x = ntohl(v3.x);
    tmp.y = ntohl(v3.y);
    tmp.z = ntohl(v3.z);
    
    return tmp;
}














struct PvpMatchMsgMatch:public PvpBussinessMsgHead,public PvpProtocalVersion
{
	private: uint8_t m_u8Plateform; public: inline void SetPlateform(uint8_t Plateform) { m_u8Plateform = Plateform; } inline uint8_t GetPlateform() const { return m_u8Plateform; }
	private: uint8_t m_u8MatchID; public: inline void SetMatchID(uint8_t MatchID) { m_u8MatchID = MatchID; } inline uint8_t GetMatchID() const { return m_u8MatchID; }
};


struct PvpMatchMsgMatchOk:public PvpBussinessMsgHead
{
	private: uint8_t m_u8MatchID; public: inline void SetMatchID(uint8_t MatchID) { m_u8MatchID = MatchID; } inline uint8_t GetMatchID() const { return m_u8MatchID; }

	private: uint64_t m_u64BattleID; public: void SetBattleID(uint64_t BattleID) { m_u64BattleID = htonll(BattleID); } uint64_t GetBattleID() const { return ntohll(m_u64BattleID); }

	private: uint32_t m_u32RobotCount; public: void SetRobotCount(uint32_t RobotCount) { m_u32RobotCount = htonl(RobotCount); } uint32_t GetRobotCount() const { return ntohl(m_u32RobotCount); }

	private: uint64_t m_u64OthersUID[PvpConst::COUNT_OF_ONE_PAIR - 1]; public: void SetOthersUID(uint64_t OthersUID, unsigned uIndex) { assert(uIndex < sizeof(m_u64OthersUID)/ sizeof(m_u64OthersUID[0])); m_u64OthersUID[uIndex] = htonll(OthersUID); } uint64_t GetOthersUID(unsigned uIndex) const { assert(uIndex < sizeof(m_u64OthersUID)/ sizeof(m_u64OthersUID[0])); return ntohll(m_u64OthersUID[uIndex]); }

public:
	
	char szNick[PvpConst::COUNT_OF_ONE_PAIR - 1][PvpConst::NICK_NAME_LEN];
	char szPicUrl[PvpConst::COUNT_OF_ONE_PAIR - 1][PvpConst::PIC_URL_LEN];
};

struct PvpGameMsgHead:public PvpBussinessMsgHead
{
	private: uint8_t m_u8Plateform; public: inline void SetPlateform(uint8_t Plateform) { m_u8Plateform = Plateform; } inline uint8_t GetPlateform() const { return m_u8Plateform; }
	private: uint8_t m_u8MatchID; public: inline void SetMatchID(uint8_t MatchID) { m_u8MatchID = MatchID; } inline uint8_t GetMatchID() const { return m_u8MatchID; }
	private: uint64_t m_u64BattleID; public: void SetBattleID(uint64_t BattleID) { m_u64BattleID = htonll(BattleID); } uint64_t GetBattleID() const { return ntohll(m_u64BattleID); }
};

struct PvpGameMsgStart :public PvpGameMsgHead
{
	private: uint32_t m_u32RobotCount; public: void SetRobotCount(uint32_t RobotCount) { m_u32RobotCount = htonl(RobotCount); } uint32_t GetRobotCount() const { return ntohl(m_u32RobotCount); }

	private: uint64_t m_u64OthersUID[PvpConst::COUNT_OF_ONE_PAIR - 1]; public: void SetOthersUID(uint64_t OthersUID, unsigned uIndex) { assert(uIndex < sizeof(m_u64OthersUID)/ sizeof(m_u64OthersUID[0])); m_u64OthersUID[uIndex] = htonll(OthersUID); } uint64_t GetOthersUID(unsigned uIndex) const { assert(uIndex < sizeof(m_u64OthersUID)/ sizeof(m_u64OthersUID[0])); return ntohll(m_u64OthersUID[uIndex]); }
};

//GameSvr ==> Client ON TCP
struct PvpGameMsgGameSvrUdpAddr :public PvpGameMsgHead
{
	private: uint32_t m_u32Ip; public: void SetIp(uint32_t Ip) { m_u32Ip = htonl(Ip); } uint32_t GetIp() const { return ntohl(m_u32Ip); }
	private: uint16_t m_u16Port; public: inline void SetPort(uint16_t Port) { m_u16Port = Port; } inline uint16_t GetPort() const { return m_u16Port; }
};

//Client ==> GameSvr ON UDP
struct PvpGameMsgClientUdpAddr :public PvpGameMsgHead
{
};

struct PvpGameMsgClientUdpAddrAcknowledge :public PvpGameMsgHead
{
};

struct PvpSpawnInfo
{
public:
    PvpSpawnInfo()
    {
        memset(this, 0x00, sizeof(*this));
    }

private: uint32_t m_u32TypeID; public: void SetTypeID(uint32_t TypeID) { m_u32TypeID = htonl(TypeID); } uint32_t GetTypeID() const { return ntohl(m_u32TypeID); }
//DESCARE_NET_WORK_32_BIT_VAR(BornDirection)
//DESCARE_NET_WORK_32_BIT_VAR(BornPosX)
//DESCARE_NET_WORK_32_BIT_VAR(BornPosY)

private: Vector3fx m_v3Gravity; public: void SetGravity(Vector3 Gravity) { m_v3Gravity = htonVector3fx(Gravity); } Vector3fx GetGravity() const { return ntohVector3fx(m_v3Gravity); }
private: Vector3fx m_v3Vel; public: void SetVel(Vector3 Vel) { m_v3Vel = htonVector3fx(Vel); } Vector3fx GetVel() const { return ntohVector3fx(m_v3Vel); }
private: Vector3fx m_v3Pos; public: void SetPos(Vector3 Pos) { m_v3Pos = htonVector3fx(Pos); } Vector3fx GetPos() const { return ntohVector3fx(m_v3Pos); }
private: uint32_t m_u32ChuckWait; public: void SetChuckWait(uint32_t ChuckWait) { m_u32ChuckWait = htonl(ChuckWait); } uint32_t GetChuckWait() const { return ntohl(m_u32ChuckWait); }


//DESCARE_NET_WORK_64_BIT_VAR(UID)
private:
uint64_t m_u64UID;

public: 
	void SetUID(uint64_t UID) //偷懒,setuid的时候随机生成出生地点
	{
		assert(PvpConst::SCREEN_WIDTH > PvpConst::SPAWN_START_POS_X * 2);
		assert(PvpConst::SCREEN_HIGH > PvpConst::SPAWN_START_POS_Y * 2);

        Vector3fx gravity = Vector3fx::Zero;
        Vector3fx vel = Vector3fx::Zero;
        Vector3fx pos = Vector3fx::Zero;
        
		PvpConst::enumPvpSpawnBornDirection eDirection = (PvpConst::enumPvpSpawnBornDirection)(rand() % PvpConst::BORN_DIRECTION_MAX); 
		switch(eDirection)
		{
		case	PvpConst::TOP_TO_BOTTOM:
            vel.y = 0;
            gravity.y = -8;
            pos.y = PvpConst::SCREEN_HIGH + rand() % PvpConst::MAX_SPAWN_POS_OFFSET;
            pos.x = PvpConst::SPAWN_START_POS_X + rand() % (PvpConst::SCREEN_WIDTH - PvpConst::SPAWN_START_POS_X *2);
    
			break;
		case	PvpConst::BOTTOM_TO_TOP:
            gravity.y = -8;
            vel.y = 20;
            pos.y = 0 - rand() % PvpConst::MAX_SPAWN_POS_OFFSET;
            pos.x = PvpConst::SPAWN_START_POS_X + rand() % (PvpConst::SCREEN_WIDTH - PvpConst::SPAWN_START_POS_X *2);

			break;
		case	PvpConst::LEFT_TO_RIGHT:
             vel.x = 20;
             pos.x = 0 - rand() % PvpConst::MAX_SPAWN_POS_OFFSET;
             pos.y = PvpConst::SPAWN_START_POS_Y + rand() % (PvpConst::SCREEN_HIGH - PvpConst::SPAWN_START_POS_Y *2);
			break;
		case	PvpConst::RIGHT_TO_LEFT:
            vel.x = -20;
            pos.x = PvpConst::SCREEN_WIDTH + rand() % PvpConst::MAX_SPAWN_POS_OFFSET;
			pos.y = PvpConst::SPAWN_START_POS_Y + rand() % (PvpConst::SCREEN_HIGH - PvpConst::SPAWN_START_POS_Y *2);
			break;
		default:
			assert(false);
            break;
		}

        //SetBornPosX(pos.x);
		//SetBornPosY(pos.y);
		//SetBornDirection(uint32_t(eDirection));

        SetGravity(gravity);
        SetPos(pos);
        SetVel(vel);
        uint32_t u32ChuckWait = rand() % PvpConst::MAX_CHUCK_WAIT;
        SetChuckWait(u32ChuckWait);
        
		m_u64UID = htonll(UID);
	}
	uint64_t GetUID() const { return ntohll(m_u64UID); }
};


struct PvpEntity
{
    unsigned m_uTypeID;
	uint64_t m_u64UID;
    
    Vector3 m_gravity;
    Vector3 m_vel;
    Vector3 m_pos;

	float   m_col_box_radius;
	bool    m_bSliced;

    unsigned m_uChuckWait;
    bool    m_bChucked;
    
    void InitBySpawnInfo(const PvpSpawnInfo &spawnInfo)
    {
        m_uTypeID = spawnInfo.GetTypeID();
	    m_u64UID = spawnInfo.GetUID();
        m_gravity = spawnInfo.GetGravity();
        m_vel = spawnInfo.GetVel();
        m_pos = spawnInfo.GetPos();
		m_col_box_radius = 30;//TODO, fixme !!
		m_bSliced = false;

        m_uChuckWait = spawnInfo.GetChuckWait();
        m_bChucked = false;

        LOG_("InitBySpawnInfo");
    }

    
    void LOG_(const char* pszDesc) const
    {
        return;







    }

    void Update(dec32 dt)
    {
        if(m_uChuckWait > 0)
            {
                if(m_uChuckWait > dt)
                {
                    m_uChuckWait -= dt;
                }
                else
                    {
                        m_uChuckWait = 0;
                    }
                return;
            }
        if(m_bSliced)
            {
                return;
            }
        if(m_bChucked && IsOffScreen())
            {
                return;
            }
   // #define SIXTY_FPS_DT				(1/60.0f)
        dt *= 60;
         Vector3 grav = m_gravity;
         // All other versions can use the correct position over time formula, but the iphone can't because it is resistant to change
         Vector3 velocity = (m_vel*dt + grav * 0.5f * (dt*dt));
        
        // if (velocity.y < 0)
        // {
        //     dec32 dampenedVelocityY = velocity.y * AIR_RESISTANCE_DAMPENING;
        //     velocity.y = velocity.y * (1 - dt) + dampenedVelocityY * dt;
        // }
         m_pos += velocity * (60.f);
         m_vel += grav * dt;


        if(!m_bChucked && !IsOffScreen())
        {
            m_bChucked = true;
        }
    }

	
	bool IsOffScreen() const
	{
	/*	float rad = m_col_box_radius;
		static Vector2 playableArea = Vector2(PvpConst::SCREEN_WIDTH / 2, PvpConst::SCREEN_HIGH / 2);//Game::GetInstance().GetPlayableArea() * 0.5f;
	 
		bool partOneOffscreen = (m_pos.y < (-playableArea.y - rad)   || 
									 m_pos.y > (playableArea.y + rad)  || 
									 m_pos.x < (-playableArea.x - rad) || 
									 m_pos.x > (playableArea.x + rad));

		return partOneOffscreen;
*/
        return m_pos.x  < 0
                || m_pos.x > PvpConst::SCREEN_WIDTH 
                || m_pos.y < 0
                || m_pos.y > PvpConst::SCREEN_HIGH
                ;
	}

	bool CanSlice() const
	{
		return (!m_bSliced) && (!IsOffScreen()) && m_bChucked;
	}
};


struct PvpGameMsgSpawnFruit:public PvpGameMsgHead
{
    //改成8bit的?
	private: uint32_t m_u32FruitCount; public: void SetFruitCount(uint32_t FruitCount) { m_u32FruitCount = htonl(FruitCount); } uint32_t GetFruitCount() const { return ntohl(m_u32FruitCount); }
	PvpSpawnInfo  m_arrSpawnInfo[PvpConst::MAX_FRUITS_SPAWN_ONCE];
	
	unsigned GetMsgLen() const
	{
		return ((uint8_t*)&(m_arrSpawnInfo[GetFruitCount()]) - (uint8_t*)this);
	}
};

struct PvpGameMsgSpawnItem:public PvpGameMsgHead
{
	private: uint32_t m_u32ItemCount; public: void SetItemCount(uint32_t ItemCount) { m_u32ItemCount = htonl(ItemCount); } uint32_t GetItemCount() const { return ntohl(m_u32ItemCount); } 	
	PvpSpawnInfo m_arrSpawnInfo[PvpConst::MAX_ITEMS_SPAWN_ONCE];

	unsigned GetMsgLen() const
	{
		return ((uint8_t*)&(m_arrSpawnInfo[GetItemCount()]) - (uint8_t*)this);
	}
};

struct PvpGameMsgSpawnBomb:public PvpGameMsgHead
{
	private: uint32_t m_u32BombCount; public: void SetBombCount(uint32_t BombCount) { m_u32BombCount = htonl(BombCount); } uint32_t GetBombCount() const { return ntohl(m_u32BombCount); } 
	PvpSpawnInfo m_arrSpawnInfo[PvpConst::MAX_BOMBS_SPAWN_ONCE];
	unsigned GetMsgLen() const
	{
		return ((uint8_t*)&(m_arrSpawnInfo[GetBombCount()]) - (uint8_t*)this);
	}
};

struct PvpGameMsgGameOver:public PvpGameMsgHead
{
	PvpGameMsgGameOver()
	{
		memset(this, 0x00, sizeof(*this));
	}

	private: uint32_t m_u32MyScore; public: void SetMyScore(uint32_t MyScore) { m_u32MyScore = htonl(MyScore); } uint32_t GetMyScore() const { return ntohl(m_u32MyScore); }
	private: uint64_t m_u64OthersUID[PvpConst::COUNT_OF_ONE_PAIR - 1]; public: void SetOthersUID(uint64_t OthersUID, unsigned uIndex) { assert(uIndex < sizeof(m_u64OthersUID)/ sizeof(m_u64OthersUID[0])); m_u64OthersUID[uIndex] = htonll(OthersUID); } uint64_t GetOthersUID(unsigned uIndex) const { assert(uIndex < sizeof(m_u64OthersUID)/ sizeof(m_u64OthersUID[0])); return ntohll(m_u64OthersUID[uIndex]); }
	private: uint32_t m_u32OthersScore[PvpConst::COUNT_OF_ONE_PAIR - 1]; public: void SetOthersScore(uint32_t OthersScore, unsigned uIndex) { assert(uIndex < sizeof(m_u32OthersScore)/ sizeof(m_u32OthersScore[0])); m_u32OthersScore[uIndex] = htonl(OthersScore); } uint32_t GetOthersScore(unsigned uIndex) const { assert(uIndex < sizeof(m_u32OthersScore)/ sizeof(m_u32OthersScore[0])); return ntohl(m_u32OthersScore[uIndex]); }
};


struct PvpGameMsgSliceFruit:public PvpGameMsgHead
{
	private: uint32_t m_u32FruitCount; public: void SetFruitCount(uint32_t FruitCount) { m_u32FruitCount = htonl(FruitCount); } uint32_t GetFruitCount() const { return ntohl(m_u32FruitCount); }
	private: uint64_t m_u64FruitUID[PvpConst::MAX_FRUITS_SPAWN_ONCE]; public: void SetFruitUID(uint64_t FruitUID, unsigned uIndex) { assert(uIndex < sizeof(m_u64FruitUID)/ sizeof(m_u64FruitUID[0])); m_u64FruitUID[uIndex] = htonll(FruitUID); } uint64_t GetFruitUID(unsigned uIndex) const { assert(uIndex < sizeof(m_u64FruitUID)/ sizeof(m_u64FruitUID[0])); return ntohll(m_u64FruitUID[uIndex]); };

	unsigned GetMsgLen() const
	{
		return ((uint8_t*)&(m_u64FruitUID[GetFruitCount()]) - (uint8_t*)this);
	}
};

struct PvpGameMsgOthersSliceFruit:public PvpGameMsgHead
{
	private: uint64_t m_u64OthersUID; public: void SetOthersUID(uint64_t OthersUID) { m_u64OthersUID = htonll(OthersUID); } uint64_t GetOthersUID() const { return ntohll(m_u64OthersUID); }
	private: uint32_t m_u32FruitCount; public: void SetFruitCount(uint32_t FruitCount) { m_u32FruitCount = htonl(FruitCount); } uint32_t GetFruitCount() const { return ntohl(m_u32FruitCount); }
	private: uint64_t m_u64FruitUID[PvpConst::MAX_FRUITS_SPAWN_ONCE]; public: void SetFruitUID(uint64_t FruitUID, unsigned uIndex) { assert(uIndex < sizeof(m_u64FruitUID)/ sizeof(m_u64FruitUID[0])); m_u64FruitUID[uIndex] = htonll(FruitUID); } uint64_t GetFruitUID(unsigned uIndex) const { assert(uIndex < sizeof(m_u64FruitUID)/ sizeof(m_u64FruitUID[0])); return ntohll(m_u64FruitUID[uIndex]); };
	
	unsigned GetMsgLen() const
	{
		return ((uint8_t*)&(m_u64FruitUID[GetFruitCount()]) - (uint8_t*)this);
	}
};

struct PvpGameMsgSliceBomb:public PvpGameMsgHead
{
	private: uint64_t m_u64BombUID; public: void SetBombUID(uint64_t BombUID) { m_u64BombUID = htonll(BombUID); } uint64_t GetBombUID() const { return ntohll(m_u64BombUID); }
};

struct PvpGameMsgOthersSliceBomb:public PvpGameMsgHead
{
	private: uint64_t m_u64OthersUID; public: void SetOthersUID(uint64_t OthersUID) { m_u64OthersUID = htonll(OthersUID); } uint64_t GetOthersUID() const { return ntohll(m_u64OthersUID); }
	private: uint64_t m_u64BombUID; public: void SetBombUID(uint64_t BombUID) { m_u64BombUID = htonll(BombUID); } uint64_t GetBombUID() const { return ntohll(m_u64BombUID); }
};


struct PvpGameMsgSliceItem:public PvpGameMsgHead
{
	private: uint32_t m_u32ItemID; public: void SetItemID(uint32_t ItemID) { m_u32ItemID = htonl(ItemID); } uint32_t GetItemID() const { return ntohl(m_u32ItemID); }
	private: uint64_t m_u64ItemUID; public: void SetItemUID(uint64_t ItemUID) { m_u64ItemUID = htonll(ItemUID); } uint64_t GetItemUID() const { return ntohll(m_u64ItemUID); }
};

struct PvpGameMsgOthersSliceItem:public PvpGameMsgHead
{
	private: uint64_t m_u64OthersUID; public: void SetOthersUID(uint64_t OthersUID) { m_u64OthersUID = htonll(OthersUID); } uint64_t GetOthersUID() const { return ntohll(m_u64OthersUID); }
	private: uint32_t m_u32ItemID; public: void SetItemID(uint32_t ItemID) { m_u32ItemID = htonl(ItemID); } uint32_t GetItemID() const { return ntohl(m_u32ItemID); }
	private: uint64_t m_u64ItemUID; public: void SetItemUID(uint64_t ItemUID) { m_u64ItemUID = htonll(ItemUID); } uint64_t GetItemUID() const { return ntohll(m_u64ItemUID); }
};


struct PvpGameMsgUseItem:public PvpGameMsgHead
{
	private: uint32_t m_u32ItemID; public: void SetItemID(uint32_t ItemID) { m_u32ItemID = htonl(ItemID); } uint32_t GetItemID() const { return ntohl(m_u32ItemID); }
	private: uint64_t m_u64ToWho; public: void SetToWho(uint64_t ToWho) { m_u64ToWho = htonll(ToWho); } uint64_t GetToWho() const { return ntohll(m_u64ToWho); }
};

struct PvpGameMsgOthersUseItem:public PvpGameMsgHead
{
	private: uint64_t m_u64SenderUID; public: void SetSenderUID(uint64_t SenderUID) { m_u64SenderUID = htonll(SenderUID); } uint64_t GetSenderUID() const { return ntohll(m_u64SenderUID); }
	private: uint32_t m_u32ItemID; public: void SetItemID(uint32_t ItemID) { m_u32ItemID = htonl(ItemID); } uint32_t GetItemID() const { return ntohl(m_u32ItemID); }
	private: uint64_t m_u64ToWho; public: void SetToWho(uint64_t ToWho) { m_u64ToWho = htonll(ToWho); } uint64_t GetToWho() const { return ntohll(m_u64ToWho); }
};


struct PvpGameMsgTimeOver :public PvpGameMsgHead
{

};

struct PvpGameMsgFinish :public PvpGameMsgHead
{
	private: uint32_t m_u32Score; public: void SetScore(uint32_t Score) { m_u32Score = htonl(Score); } uint32_t GetScore() const { return ntohl(m_u32Score); }
};


#pragma pack()



#endif //_IDS_PVP_MSG_H_INCLUDED_ 
